\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{url}
\usepackage{amsmath}
\usepackage{float}


\title{
	{Computer Vision 1 - Assignment 3 \\
	Harris Corner Detector and Optical Flow}
}
\author{
Selene Baez Santamaria (10985417) - Andrea Jemmett (11162929)}
\date{\today}

\begin{document}

\maketitle

\section{Harris Corner Detector}
% Question: "Demo function"
To implement the Harris Corner Detector we decided to use the function we
implemented on previous assignments. This way we can exploit the benefits of
kernel separability and improve performance. Thus, we created horizontal and
vertical Gaussian kernels, and applied a Gaussian first order derivative kernel to the image, read in a gray scale format. The image gradients are shown in Figure
\ref{fig:partialDerivatives_pingpong} and \ref{fig:partialDerivatives_person}.

\begin{figure}[H] \centering
	\includegraphics[width=.8\textwidth]{imgs/derivatives_pingpong.jpg}
	\caption{Image gradients for first Ping Pong image}
	\label{fig:partialDerivatives_pingpong}
\end{figure}

\begin{figure}[H] \centering
	\includegraphics[width=.8\textwidth]{imgs/derivatives_person.jpg}
	\caption{Image gradients for first Toy Person image}
	\label{fig:partialDerivatives_person}
\end{figure}

Then, we created the $Q$ matrix, first by squaring the gradients (i.e.
($I_x)^2$ and ($I_y)^2$) and multiplying them with each other (i.e. $I_x *
I_y$), and then by convolving the resulting with a Gaussian kernel. With these
components we were able to compute $H$ using Equation $12$ shown in the
assignment instructions. A visualization for the scaled surfaces are shown in
Figure \ref{fig:surface_pingpong} and \ref{fig:surface_person}.

\begin{figure}[H] \centering
	\includegraphics[width=.8\textwidth]{imgs/surface_pingpong.jpg}
	\caption{$H$ surface for first Ping Pong image. Local maxima are
		observed along the ping pong table, and the hand.}
	\label{fig:surface_pingpong}
\end{figure}

\begin{figure}[H] \centering
	\includegraphics[width=.8\textwidth]{imgs/surface_person.jpg}
	\caption{$H$ surface for first Toy Person image. Local maxima are
		observed on the power outlet and on the toy person.}
	\label{fig:surface_person}
\end{figure}

Finally, to choose the corner points we considered two conditions:
\begin{enumerate} 
	\item A corner point must be a local maximum. To check for
		this we need to compare its value with all its neighbors' within
		a given window.
	\item A corner point must have a higher $H$
		value than a given threshold.
\end{enumerate}

To create an accurate corner detector we need to tune the parameters. We know that $\sigma$ controls the smoothness of surface $H$. When $\sigma >> 1$, the main corners are detected but there is misplacement on their location, while $\sigma << 1$ introduces noise by detecting corner points in the background. The window size determines the closeness at which points may be, therefore a larger window prevents them from clustering and reduces the final amount of points. Finally, the threshold regulates the pressure for candidate points to become corner points. Thus, a higher threshold reduces the final number of points.
 
After tuning, the chosen values for the final detector are:
\begin{itemize}
	\item $kernel  length = 11$
	\item $\sigma = 1.5$
	\item $window  size = 11$
	\item $threshold = 10$
\end{itemize}

To validate our detector we compared it with the Matlab corner function. In order to have a fair comparison, we make it so that the built in function returns the same number of points as our detector and qualitatively compare them by visually plotting the corner points.
 
\begin{figure}[H] \centering
	\begin{subfigure}{.5\textwidth} \centering
		\includegraphics[width=.9\textwidth]{imgs/ourCorners_pingpong.jpg}
		\caption{Our implementation of Harris Corner Detector.}
		\label{fig:ourCorners_pingpong}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}	\centering
		\includegraphics[width=.9\textwidth]{imgs/matlabCorners_pingpong.jpg}
		\caption{Matlab's built in Corner function.}
		\label{fig:matlabCorners_pingpong}
	\end{subfigure}
	\caption{Corner points in first Ping Pong image}
	\label{fig:corners_pingpong}
\end{figure}

In case of the Ping Pong image, $n_corners = 63$. On the one hand, our detector is able to detect points in the ball and along the sleeve. On the other hand, the Matlab function introduces noisy points in the background and fails to detect the racket. 

\begin{figure}[H] \centering
	\begin{subfigure}{.5\textwidth} \centering
		\includegraphics[width=.9\textwidth]{imgs/ourCorners_person.jpg}
		\caption{Our implementation of Harris Corner Detector.}
		\label{fig:ourCorners_person}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}	\centering
		\includegraphics[width=.9\textwidth]{imgs/matlabCorners_person.jpg}
		\caption{Matlab's built in Corner function.}
		\label{fig:matlabCorners_person}
	\end{subfigure}
	\caption{Corner points in first Toy person image}
	\label{fig:corners_person}
\end{figure}

In case of the Toy person image, $n_corners = 27$. Our detector finds more corner points in the frame of the power outlet and detects three of the four edges of the white central box while the Matlab function focuses more on the toy.

\section{Lucas-Kanade Algorithm for Optical Flow}
In order to implement the Lucas Kanade method for Optical Flow we started by computing the $x-y$ gradients of the images using our first order Gaussian kernel as stated in the previous section. 

% To get the full partial $x-y$ derivatives, we added the corresponding gradients from image in $t_1$ and $t_2$. % NOT SURE WHY? ASSIGNMENT SAYS IT?S ONLY DERIVATIVE EVALUATED AT CURRENT TIME.
To obtain the $t$ gradient we simply convolve the images with a uniform kernel of value $0.5$ for image in $t_1$ and a value of $- 0.5$ for image in $t_2$. 

Then we divide the image into non overlapping regions, and loop through them. For each section we solve the system of equations to find velocities.

\begin{figure}[H] \centering
	\includegraphics[width=.8\textwidth]{imgs/sphere.jpg}
	\caption{Optical flow as determined by Lucas Kanade algorithm, applied to Sphere images.}
	\label{fig:sphere_lucas}
\end{figure}

\begin{figure}[H] \centering
	\includegraphics[width=.8\textwidth]{imgs/synth.jpg}
	\caption{Optical flow as determined by Lucas Kanade algorithm, applied to Synth images}
	\label{fig:synth_lucas}
\end{figure}


\section{Tracking}

\end{document}